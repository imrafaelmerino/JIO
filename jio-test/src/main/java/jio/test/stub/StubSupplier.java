package jio.test.stub;

import fun.gen.Gen;
import jio.IO;

import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.Executor;
import java.util.function.Supplier;

/**
 * A stub for generating `IO` instances using generators. Some useful generators are defined in the {@link Gens} class,
 * where delays and failures can be produced based on the call number to the generator. Generators are composable using
 * the `Combinators` class.
 * <p>
 * Example of generating `IO` instances with generators and composition:
 * <pre>
 * {@code
 * var gen1 = Gens.seq(n -> IO.succeed(n));
 * var gen2 = Gens.fail(new RuntimeException("bad luck!"));
 * var gen = Combinators.oneOf(gen1, gen2);
 * }
 * </pre>
 * <p>
 * This class allows you to generate `IO` instances with various generators and customize their behavior. You can also
 * specify an executor using the {@link #withExecutor(Executor)} method for handling asynchronous IO operations.
 *
 * @param <O> The type of value generated by the stub.
 * @see Gens
 * @see Gen
 * @see fun.gen.Combinators
 */
public class StubSupplier<O> implements Supplier<IO<O>> {

    private final Gen<IO<O>> gen;
    Executor executor;

    private StubSupplier(final Gen<IO<O>> gen) {
        this.gen = gen;
    }

    /**
     * Creates a new stub using the provided generator of IO effects.
     *
     * @param gen The generator for creating `IO` instances.
     * @param <O> The type of value to generate.
     * @return A new stub instance.
     */
    public static <O> StubSupplier<O> ofIOGen(final Gen<IO<O>> gen) {
        return new StubSupplier<>(Objects.requireNonNull(gen));
    }
    /**
     * Creates a new stub using the provided generator of values with a specified delay generator.
     *
     * @param gen      The generator for creating values of type O.
     * @param delayGen The generator for creating durations to delay the `IO` operations.
     * @param <O>      The type of value to generate.
     * @return A new stub instance.
     */
    public static <O> StubSupplier<O> ofDelayedGen(final Gen<O> gen,
                                                   final Gen<Duration> delayGen
                                                  ) {
        Supplier<Duration> delayed = delayGen.sample();
        return new StubSupplier<>(gen.map(n -> IO.succeed(n).sleep(delayed.get())));
    }
    /**
     * Creates a new stub using the provided generator of IO effects with a specified delay generator.
     *
     * @param gen      The generator for creating `IO` instances.
     * @param delayGen The generator for creating durations to delay the `IO` operations.
     * @param <O>      The type of value to generate.
     * @return A new stub instance.
     */
    public static <O> StubSupplier<O> ofDelayedIOGen(final Gen<IO<O>> gen,
                                                     final Gen<Duration> delayGen
                                                    ) {
        Supplier<Duration> delayed = delayGen.sample();
        return new StubSupplier<>(gen.map(io -> io.sleep(delayed.get())));
    }


    /**
     * Creates a new stub using the provided generator of values.
     *
     * @param gen The generator for creating values of type O
     * @param <O> The type of value to generate.
     * @return A new stub instance.
     */
    public static <O> StubSupplier<O> ofGen(final Gen<O> gen) {
        return new StubSupplier<>(Gens.lift(gen));
    }

    /**
     * Sets the executor for this stub. The executor is used for asynchronous IO operations. Use this method when you
     * want to customize the executor used by the generated `IO` instances.
     *
     * @param executor The executor to be used for asynchronous operations.
     * @return This stub instance with the executor set.
     */
    public StubSupplier<O> withExecutor(Executor executor) {
        this.executor = Objects.requireNonNull(executor);
        return this;
    }


    /**
     * Generates an `IO` instance using the specified generator, allowing for lazy execution and composition.
     *
     * @return The generated `IO` instance.
     */
    @Override
    public IO<O> get() {
        return executor == null ?
                IO.lazy(gen.sample())
                  .then(it -> it) :
                IO.lazy(gen.sample(),
                        executor)
                  .then(it -> it);
    }
}
